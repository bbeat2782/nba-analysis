<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>NBA Player Passing Network Comparison</title>
  <script src="https://d3js.org/d3.v4.min.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
    }
    .graph-container {
      display: inline-block;
      vertical-align: top;
      margin-right: 20px;
      border: 1px solid #ccc;
      padding: 10px;
    }
    .links path {
      stroke: #999;
      stroke-opacity: 0.6;
      fill: none;
    }
    .nodes circle {
      stroke: #fff;
      stroke-width: 1.5px;
      cursor: grab;
    }
    .tooltip {
      position: absolute;
      background: white;
      border: 1px solid #ccc;
      padding: 5px;
      font-size: 14px;
      visibility: hidden;
    }
  </style>
</head>
<body>
  <p>
    <a href="bipartite.html" style="display: inline-block; padding: 10px 20px; background-color: #007bff; color: white; text-decoration: none; border-radius: 5px;">
      View Bipartite Graph
    </a>
  </p>

  <h2>NBA Player Passing Network Comparison</h2>

  <!-- Graph A container -->
  <div class="graph-container" id="graphA">
    <h3>Graph A</h3>
    <label for="season-select-A">Select Season:</label>
    <select id="season-select-A" onchange="updateGraph('A')">
      <option value="">-- Select a Season --</option>
    </select>
    <br>
    <label for="team-select-A">Select Team:</label>
    <select id="team-select-A" onchange="updateGraph('A')">
      <option value="">-- Select a Team --</option>
    </select>
    <br>
    <label for="edge-type-A">Node Size:</label>
    <select id="edge-type-A" onchange="updateGraph('A')">
      <option value="in-degree" selected>In-Degree</option>
      <option value="out-degree">Out-Degree</option>
    </select>
    <br>
    <svg id="svg-A" width="700" height="600"></svg>
  </div>

  <!-- Graph B container -->
  <div class="graph-container" id="graphB">
    <h3>Graph B</h3>
    <label for="season-select-B">Select Season:</label>
    <select id="season-select-B" onchange="updateGraph('B')">
      <option value="">-- Select a Season --</option>
    </select>
    <br>
    <label for="team-select-B">Select Team:</label>
    <select id="team-select-B" onchange="updateGraph('B')">
      <option value="">-- Select a Team --</option>
    </select>
    <br>
    <label for="edge-type-B">Node Size:</label>
    <select id="edge-type-B" onchange="updateGraph('B')">
      <option value="in-degree" selected>In-Degree</option>
      <option value="out-degree">Out-Degree</option>
    </select>
    <br>
    <svg id="svg-B" width="700" height="600"></svg>
  </div>

  <script>
    // Valid NBA Team IDs (2001-2024)
    const validNBATeamIDs = new Set([
        1610612737, 1610612738, 1610612751, 1610612766, 1610612741, 1610612739,
        1610612742, 1610612743, 1610612765, 1610612744, 1610612745, 1610612754,
        1610612746, 1610612747, 1610612763, 1610612748, 1610612749, 1610612750,
        1610612740, 1610612752, 1610612760, 1610612753, 1610612755, 1610612756,
        1610612757, 1610612758, 1610612759, 1610612761, 1610612762, 1610612764
    ]);

    const nbaTeamIdToName = {
        1610612737: "Atlanta Hawks",
        1610612738: "Boston Celtics",
        1610612751: "Brooklyn Nets",
        1610612766: "Charlotte Hornets",
        1610612741: "Chicago Bulls",
        1610612739: "Cleveland Cavaliers",
        1610612742: "Dallas Mavericks",
        1610612743: "Denver Nuggets",
        1610612765: "Detroit Pistons",
        1610612744: "Golden State Warriors",
        1610612745: "Houston Rockets",
        1610612754: "Indiana Pacers",
        1610612746: "LA Clippers",
        1610612747: "Los Angeles Lakers",
        1610612763: "Memphis Grizzlies",
        1610612748: "Miami Heat",
        1610612749: "Milwaukee Bucks",
        1610612750: "Minnesota Timberwolves",
        1610612740: "New Orleans Pelicans",
        1610612752: "New York Knicks",
        1610612760: "Oklahoma City Thunder",
        1610612753: "Orlando Magic",
        1610612755: "Philadelphia 76ers",
        1610612756: "Phoenix Suns",
        1610612757: "Portland Trail Blazers",
        1610612758: "Sacramento Kings",
        1610612759: "San Antonio Spurs",
        1610612761: "Toronto Raptors",
        1610612762: "Utah Jazz",
        1610612764: "Washington Wizards"
    };


    // Global raw data
    var allNodes = [], allLinks = [];
    var teamNames = new Set(), seasonYears = new Set();
    var color = d3.scaleOrdinal(d3.schemeCategory10);

    // Each graph has its own data (after filtering & copying)
    var graphData = {
      'A': { nodes: [], links: [] },
      'B': { nodes: [], links: [] }
    };

    // Force simulations for each graph
    var simulations = {
      'A': null,
      'B': null
    };

    // Load JSON data
    d3.json("scripts/graph_data.json", function(error, data) {
      if (error) {
        console.error("Error loading JSON:", error);
        return;
      }

      allNodes = data.nodes;
      allLinks = data.links;

      // // Gather all distinct teams and seasons
      // allNodes.forEach(d => {
      //   teamNames.add(d.teamName.trim());
      //   seasonYears.add(d.season);
      // });

      let teamIDs = new Set();
      allNodes.forEach(d => {
          if (validNBATeamIDs.has(d.group)) {
              teamIDs.add(d.group); // Store only valid NBA team IDs
              teamNames.add(d.teamName.trim());
              seasonYears.add(d.season);
          }
          seasonYears.add(d.season);
      });


      // Sort them for consistent dropdown ordering
      let sortedSeasons = Array.from(seasonYears).map(Number).sort((a, b) => a - b);
      // Extract unique team names from dataset while filtering by valid team IDs
      let teamIdToName = {};
      allNodes.forEach(d => {
          if (validNBATeamIDs.has(d.group)) {
              teamIdToName[d.group] = d.teamName.trim(); // Store team name from JSON
          }
      });

      // Sort teams dynamically based on names from JSON
      let sortedTeams = Object.entries(teamIdToName)
          .sort((a, b) => a[1].localeCompare(b[1])) // Sort by team name
          .map(entry => ({ id: entry[0], name: entry[1] })); // Convert back to list



      // Populate dropdowns for both graphs
      // ['A', 'B'].forEach(graphLabel => {
      //   // Seasons
      //   let seasonDropdown = d3.select("#season-select-" + graphLabel);
      //   sortedSeasons.forEach(season => {
      //     seasonDropdown.append("option")
      //       .attr("value", season)
      //       .text(season)
      //       // Example: default to 2024 if you like
      //       .property("selected", season === 2024);
      //   });

      //   // Teams
      //   let teamDropdown = d3.select("#team-select-" + graphLabel);
      //   sortedTeams.forEach(team => {
      //     let option = teamDropdown.append("option")
      //       .attr("value", team)
      //       .text(team);
      //     // Example: default to Lakers (Graph A), Clippers (Graph B)
      //     if ((graphLabel === 'A' && team === "Lakers") || 
      //         (graphLabel === 'B' && team === "Clippers")) {
      //       option.property("selected", true);
      //     }
      //   });
      // });

      ['A', 'B'].forEach(graphLabel => {
          let seasonDropdown = d3.select("#season-select-" + graphLabel);
          sortedSeasons.forEach(season => {
            seasonDropdown.append("option")
              .attr("value", season)
              .text(season)
              // Example: default to 2024 if you like
              .property("selected", season === 2024);
          });
          let teamDropdown = d3.select("#team-select-" + graphLabel);

          sortedTeams.forEach(team => {
              // let teamName = nbaTeamIdToName[teamId] || "Unknown Team"; // Get the correct team name
              let option = teamDropdown.append("option")
                  .attr("value", team.name) // Store team ID
                  .text(team.name); // Use team name from JSON

              // Example: Default Lakers for Graph A, Clippers for Graph B
              if ((graphLabel === 'A' && team.name.includes("Lakers")) || 
                  (graphLabel === 'B' && team.name.includes("Clippers"))) {
                  option.property("selected", true);
              }
          });
      });


      // Initial draws
      updateGraph('A');
      updateGraph('B');
    });

    // Filter and draw a graph
    function updateGraph(graphLabel) {
      
      // 1) Get user selections
      let season = document.getElementById("season-select-" + graphLabel).value;
      let team = document.getElementById("team-select-" + graphLabel).value.trim();
      let edgeType = document.getElementById("edge-type-" + graphLabel).value;
      let svg = d3.select("#svg-" + graphLabel);
      let width = +svg.attr("width"), height = +svg.attr("height");
      
      // 2) Filter and **copy** nodes
      let filteredNodes = allNodes
        .filter(d => (!season || d.season == season) &&
                     (!team || d.teamName.trim() === team))
        // Critical: create a copy so we don't mutate the global reference
        .map(d => Object.assign({}, d));


      // 3) Filter and **copy** links
      let nodeIDs = new Set(filteredNodes.map(d => d.id));
      let filteredLinks = allLinks
        .filter(d => nodeIDs.has(d.source) && nodeIDs.has(d.target) &&
                     (!season || d.season == season))
        .map(d => Object.assign({}, d));

      // 4) Compute in/out-degree for node sizing
      let degreeMap = new Map(filteredNodes.map(n => [n.id, 0]));
      filteredLinks.forEach(link => {
        if (edgeType === "in-degree") {
          degreeMap.set(link.target, (degreeMap.get(link.target) || 0) + link.value);
        } else {
          degreeMap.set(link.source, (degreeMap.get(link.source) || 0) + link.value);
        }
      });
      filteredNodes.forEach(n => n.degree = degreeMap.get(n.id) || 0);

      // 5) Store these copies in graphData
      graphData[graphLabel].nodes = filteredNodes;
      graphData[graphLabel].links = filteredLinks;

      // If the graph is already drawn, only update node sizes
      // if (simulations[graphLabel]) {
      //     let svg = d3.select("#svg-" + graphLabel);
      //     let container = svg.select("g");

      //     // Update the radius of existing nodes
      //     container.selectAll(".nodes circle")
      //         .data(filteredNodes, d => d.id)  // Ensure data binding by ID
      //         .transition().duration(500)  // Smooth transition for size change
      //         .attr("r", d => Math.sqrt(d.degree) + 5);

      //     // return; // Stop further updates to prevent re-rendering
      // }

      // 6) (Re)create the force simulation for this graph
      simulations[graphLabel] = d3.forceSimulation()
          .force("link", d3.forceLink().id(d => d.id).distance(200))
          .force("charge", d3.forceManyBody().strength(-300))
          .force("center", d3.forceCenter(width / 2, height / 2))
          .force("collide", d3.forceCollide().radius(30).strength(1));

      // Start with a higher alpha for better layout
      simulations[graphLabel].alpha(1).restart();

      // 7) Draw or redraw (only the first time)
      drawGraph(graphLabel, svg, width, height);
    }

    function drawGraph(graphLabel, svg, width, height) {
      // 1) Clear existing content
      svg.selectAll("*").remove();

      // 2) Add zoomable container
      let container = svg.append("g");

      let zoom = d3.zoom()
          .scaleExtent([0.01, 4]) // Allow zooming between 50% (zoomed out) and 200% (zoomed in)
          .on("zoom", () => container.attr("transform", d3.event.transform));

      svg.call(zoom);

      svg.append("defs").append("marker")
        .attr("id", "arrowhead")  // Ensure consistent ID
        .attr("viewBox", "0 -5 10 10")
        .attr("refX", 12)  // Adjusted for proper visibility
        .attr("refY", 0)
        .attr("markerWidth", 4)  // Small arrow size
        .attr("markerHeight", 4) // Small arrow size
        .attr("orient", "auto")
        .append("path")
        .attr("d", "M0,-3L6,0L0,3")  // Smaller triangle
        .attr("fill", "#999")
        .attr("fill-opacity", 0.75);  // Set opacity same as links

      // 4) Apply an initial zoom-out transformation (80% of original size)
      svg.call(zoom.transform, d3.zoomIdentity.scale(0.6));
      // svg.call(d3.zoom().on("zoom", () => container.attr("transform", d3.event.transform)));

      // 3) Extract the data for this graph
      let nodes = graphData[graphLabel].nodes;
      let links = graphData[graphLabel].links;
      let simulation = simulations[graphLabel];

      // 4) Convert link sources/targets to actual node objects
      let nodeMap = new Map(nodes.map(d => [d.id, d]));
      let processedLinks = links.map(l => ({
        source: nodeMap.get(l.source),
        target: nodeMap.get(l.target),
        value: l.value
      })).filter(l => l.source && l.target);

      // 5) Identify bidirectional links
      let linkCount = new Map();
      processedLinks.forEach(l => {
        let key = l.source.id + "-" + l.target.id;
        let revKey = l.target.id + "-" + l.source.id;
        if (linkCount.has(revKey)) {
          linkCount.set(revKey, linkCount.get(revKey) + 1);
          linkCount.set(key, linkCount.get(revKey));
        } else {
          linkCount.set(key, 1);
        }
      });

      let link = container.append("g")
        .attr("class", "links")
        .selectAll("path")
        .data(processedLinks)
        .enter().append("path")
        .attr("stroke", "#999")
        .attr("stroke-opacity", 0.6)
        .attr("stroke-width", d => Math.sqrt(d.value) + 1)
        .attr("fill", "none")
        .attr("marker-end", "url(#arrowhead)") // Corrected reference
        .style("stroke-linecap", "round");

      // 7) Create node elements
      let node = container.append("g")
        .attr("class", "nodes")
        .selectAll("circle")
        .data(nodes)
        .enter().append("circle")
        .attr("r", d => Math.sqrt(d.degree) + 5)
        .attr("fill", d => color(d.teamName.trim()))
        .call(d3.drag()
          .on("start", d => dragstarted(d, simulation))
          .on("drag", d => dragged(d, simulation))
          .on("end", d => dragended(d, simulation))
        );

      // 8) Add a tooltip
      let tooltip = d3.select("body").append("div")
        .attr("class", "tooltip")
        .style("visibility", "hidden");

        node.on("mouseover", function(event) {
          let d = d3.select(this).datum();
          
          // Get the selected edge type (in-degree or out-degree)
          let edgeType = document.getElementById("edge-type-" + graphLabel).value;

          // Highlight only connected links and arrows based on edge type
          link.style("stroke-opacity", linkData => {
              if (edgeType === "in-degree") {
                  return linkData.target.id === d.id ? 0.6 : 0.1;  // Highlight incoming edges
              } else {
                  return linkData.source.id === d.id ? 0.6 : 0.1;  // Highlight outgoing edges
              }
          });

          link.attr("marker-end", linkData => {
              if (edgeType === "in-degree") {
                  return linkData.target.id === d.id ? "url(#arrowhead)" : "none";  // Highlight incoming edges
              } else {
                  return linkData.source.id === d.id ? "url(#arrowhead)" : "none";  // Highlight outgoing edges
              }
          });

          // Highlight only connected nodes based on edge type
          node.style("opacity", nodeData => {
              return nodeData.id === d.id || processedLinks.some(link => 
                  (edgeType === "in-degree" && link.target.id === d.id && link.source.id === nodeData.id) ||
                  (edgeType === "out-degree" && link.source.id === d.id && link.target.id === nodeData.id)
              ) ? 1 : 0.2;
          });

          tooltip.style("visibility", "visible")
              .html(
                  `<b>${d.playerName || "Unknown"}</b><br>
                  Team: ${d.teamName || "N/A"}<br>
                  Season: ${d.season}<br>
                  Degree: ${d.degree || 0}`
              )
              .style("top", (event.pageY + 10) + "px")
              .style("left", (event.pageX + 10) + "px");
      })
      .on("mouseout", function() {
          // Reset link, arrow, and node opacity
          link.style("stroke-opacity", 0.6);
          link.attr("marker-end", "url(#arrowhead)");
          node.style("opacity", 1);
          tooltip.style("visibility", "hidden");
      });


      // 9) Update simulation with new data
      simulation.nodes(nodes).on("tick", () => {
        link.attr("d", function(d) {
          // Check if bidirectional
          let key = d.source.id + "-" + d.target.id;
          let revKey = d.target.id + "-" + d.source.id;
          let isBidirectional = linkCount.has(revKey);

          let dx = d.target.x - d.source.x;
          let dy = d.target.y - d.source.y;
          let distance = Math.sqrt(dx * dx + dy * dy);

          // Normalize direction vector
          let normX = dx / (distance || 1);
          let normY = dy / (distance || 1);
          
          // Get radius of source & target nodes to prevent overlap
          let radiusSource = Math.sqrt(d.source.degree) + 5; // Source node size
          let radiusTarget = Math.sqrt(d.target.degree) + 5 + 2; // Target node + extra padding for arrow
          
          // Perpendicular offset for bidirectional links
          let perpX = -normY, perpY = normX;
          let offset = isBidirectional ? 4 : 0;

          // Adjusted start and end points (shorten edges to stop at node boundary)
          let x1 = d.source.x + normX * radiusSource + perpX * offset;
          let y1 = d.source.y + normY * radiusSource + perpY * offset;
          let x2 = d.target.x - normX * radiusTarget + perpX * offset;
          let y2 = d.target.y - normY * radiusTarget + perpY * offset;

          return `M${x1},${y1}L${x2},${y2}`;
        });

        node.attr("cx", d => d.x).attr("cy", d => d.y);
      });


      simulation.force("link").links(processedLinks);
      simulation.alpha(1).restart();
    }

    // Drag event helpers
    function dragstarted(d, simulation) {
      if (!d3.event.active) simulation.alphaTarget(0.3).restart();
      d.fx = d.x; d.fy = d.y;
    }
    function dragged(d) {
      d.fx = d3.event.x; d.fy = d3.event.y;
    }
    function dragended(d, simulation) {
      if (!d3.event.active) simulation.alphaTarget(0);
      d.fx = null; d.fy = null;
    }
  </script>
</body>
</html>
